# üìò Learnings from Implementing Shamir‚Äôs Secret Sharing for Files

This project implements **file-level secret sharing** using **Shamir‚Äôs Secret Sharing (SSS)**. We explored splitting any file (binary or text) into multiple shares such that **any `k` shares out of `n`** can reconstruct the original file. This exercise taught us several **key concepts, challenges, and best practices** when implementing SSS in real-world scenarios.

------

## **1Ô∏è‚É£ Understanding the Core Concepts**

1. **Shamir‚Äôs Secret Sharing**
   - Based on **polynomial interpolation over finite fields (mod prime)**.
   - The secret (file chunk) is the **polynomial‚Äôs constant term**.
   - `n` shares are generated by evaluating the polynomial at random `x` values.
   - Any `k` shares can reconstruct the secret using **Lagrange Interpolation**.
2. **Threshold Security**
   - **k-of-n scheme**: Need at least `k` shares to reconstruct.
   - Any fewer than `k` shares leak **zero information** about the original file.

------

## **2Ô∏è‚É£ Practical Challenges with File-Based SSS**

1. **Binary File Support**
   - Directly splitting binary files can corrupt data.
   - **Solution:** Encode file to **Base64** before splitting to ensure ASCII-safe processing.
2. **File Chunking**
   - We cannot handle very large files as a single number.
   - **Solution:** Auto-calculate **chunk size** based on key strength:
     - 256-bit ‚Üí 32 bytes
     - 512-bit ‚Üí 64 bytes
     - 1024-bit ‚Üí 128 bytes
     - 2048-bit ‚Üí 256 bytes
   - This allows Shamir‚Äôs Secret Sharing to process arbitrarily large files.
3. **Random `x` Values**
   - Initially, we thought to use **sequential indices (1,2,3‚Ä¶)**.
   - **Learning:** For **better security**, generate **random unique `x`** for each share.
   - Store `(x, y)` for each chunk in the share file.

------

## **3Ô∏è‚É£ Designing the Share File Format**

A well-structured share file helps both **storage** and **reconstruction**:

```
php-templateCopyEdit# ORIGINAL_FILE: example.pdf
# ORIGINAL_HASH: 3f2c...a91
# SHARE_INDEX: 1
# TOTAL_CHUNK_COUNT: 4
# PRIME: 327987239821...
<x0> <y0>
<x1> <y1>
<x2> <y2>
<x3> <y3>
```

- **Metadata lines (first 5):**
  1. Original filename
  2. SHA-256 hash for verification
  3. Share index (for reference)
  4. Total chunk count
  5. Prime used for modular arithmetic
- **Subsequent lines:**
  - Each line represents a chunk‚Äôs `(x, y)` pair

‚úÖ **Chunk index is implicit** = line number ‚àí 5

------

## **4Ô∏è‚É£ Reconstruction Process Learnings**

1. **Lagrange Interpolation**
   - Used to recover the polynomial at `x=0`.
   - Must always work **modulo prime**.
2. **BigInteger Pitfalls**
   - **Leading zeros** in `BigInteger.toByteArray()` need trimming.
   - Otherwise, reconstructed Base64 strings may get corrupted.
3. **Data Integrity Verification**
   - Always compute a **SHA-256 hash** of the original file.
   - After reconstruction, compare hashes to detect corruption.
4. **Partial Share Handling**
   - If fewer than `k` shares are provided ‚Üí reconstruction is **impossible**.
   - This is an inherent property of Shamir‚Äôs scheme.

------

## **5Ô∏è‚É£ Security & Design Considerations**

- **Random Prime Generation**
  - A new **large prime** is generated based on `keySize` (256, 512, 1024, 2048 bits).
  - Must be **larger than any secret chunk**.
- **Minimal Metadata Exposure**
  - We do **not store chunk index** in the file; line order is sufficient.
  - Reduces leakage and makes the format concise.
- **Integrity + Confidentiality**
  - Even if an attacker steals `k-1` shares:
    - **File cannot be reconstructed**
    - **Hash cannot be verified**

------

## **6Ô∏è‚É£ Key Takeaways for Future Projects**

1. **Always Base64 encode binary data** before SSS splitting.
2. **Automate chunk sizing** based on key size for simplicity.
3. **Use random `x` values** instead of sequential indices for stronger security.
4. **Store `(x, y)` pairs** per chunk in each share file.
5. **Verify integrity using SHA-256** after reconstruction.
6. **Design share files to be human-readable** but machine-friendly for parsing.
7. **Lagrange interpolation** requires careful modular arithmetic to avoid sign issues.
8. **SecureRandom** must be used instead of `Random` to avoid predictable shares.

------

## **7Ô∏è‚É£ Example Workflow**

**Split File:**

```
bash


CopyEdit
java com.mikcore.shamir.FileSplitter input.pdf 1024 3 5
```

- Converts file ‚Üí Base64 ‚Üí Chunks
- Applies Shamir‚Äôs Secret Sharing ‚Üí 5 shares
- Any 3 shares can reconstruct

**Reconstruct File:**

```
bash


CopyEdit
java com.mikcore.shamir.ShamirDecrypt output/ 3
```

- Reads 3 or more share files
- Performs Lagrange interpolation on each chunk
- Reconstructs original binary and verifies SHA-256 hash

------

## **8Ô∏è‚É£ What This Exercise Taught Us**

- Translating **mathematical cryptography** into **practical file processing** requires:
  1. Careful data encoding
  2. Chunking strategy
  3. Strong randomness
  4. Integrity verification
- Small mistakes in **byte handling** or **mod arithmetic** can silently corrupt data.
- By iterating through **trial-and-error and debugging**, we created a **robust, production-ready SSS file splitter**.